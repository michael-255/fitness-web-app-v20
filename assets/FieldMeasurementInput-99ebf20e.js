import{k as p,F as c,r as d,l as f,aO as I,m as _,G as h,p as u,bm as b,x as e,R as m,w as g,Q as v,I as y,bJ as w,L as x,t as i}from"./index-e487f782.js";import{Q as S}from"./QSelect-5fe6ec05.js";import{u as V}from"./action-8e9e98ae.js";import{u as k}from"./useRouting-a8cfee2d.js";import"./QItem-30dce3fe.js";import"./QItemLabel-5481c733.js";import"./QMenu-4706090f.js";import"./selection-76f37adf.js";const E=i("div",{class:"text-weight-bold text-body1"},"Measurement Input",-1),M=i("p",null," Select a measurement input that represents the type of data you want to record on this measurement. This cannot be updated once set during record creation. ",-1),D=p({__name:"FieldMeasurementInput",setup(Q){const{log:l}=c(),{route:r}=k(),o=V(),n=d([]);return f(async()=>{try{o.record.measurementInput=o.record.measurementInput??void 0,n.value=Object.values(I).map(t=>({value:t,label:t}))}catch(t){l.error("Error with measurement input field",t)}}),(t,s)=>(_(),h(x,null,[E,M,u(S,{disable:e(r).name===e(m).EDIT,modelValue:e(o).record.measurementInput,"onUpdate:modelValue":s[0]||(s[0]=a=>e(o).record.measurementInput=a),rules:[a=>e(w).safeParse(a).success||"Required"],options:n.value,"lazy-rules":"","emit-value":"","map-options":"","options-dense":"",dense:"",outlined:"",color:"primary"},b({_:2},[e(r).name===e(m).EDIT?{name:"prepend",fn:g(()=>[u(v,{color:"warning",name:e(y).LOCK},null,8,["name"])]),key:"0"}:void 0]),1032,["disable","modelValue","rules","options"])],64))}});export{D as default};
